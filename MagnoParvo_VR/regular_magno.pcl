#Magno Test pcl file                    
# 10/7//2003
# This version uses the new luminances
#open and sort through the header stuff in the
#dmmagn.lst file.
#
# 2/20/2004 - Converted to work with EGI systems NetStation.
#     remove all set_port_codes because it'll be using the
#     serial port from now on.
#
# 3/10/2004 - Responses are handled by Net Station
#
# 3/31/2004 - Now works with keys.
#
# 4/2/2004 - Made the keys work.
#            Tried to get the trsp and response functions to work
#            I still don't know what they do.  *sigh* 

# 6/9/2004  MODIFED for UO luminosity  pec  

# 6/10/2004 new pictures RV 
# 6/10/2004 renamed from regular_magno.pcl to magno_vr.pcl  RV

parameter_window.remove_all(); #make it so the subjects don't see the "false alarms"

int NumPics=7;

loop
until
   clock.time() > 0
begin;
end;

input_file in = new input_file;
in.open(".\\MagnoParvo_VR_STIMS\\dmmagno.lst");
#it has 11 lines of header
loop
   int i = 1;
until
   i > 11
begin
   in.get_line();
   i = i + 1;
end;

sub
   double calc_gray_voltage(double voltage)
begin
   # I used a 2nd order polynomial fit for the
   # luminance values in excel.
   # Y = 0.0003x^2 - 0.0229x + 0.4524
   # The above eq is based on values from 0-255.
   # This is the solution using the quadratic equation.
#   voltage = (0.1085 + sqrt( 0.01177225 - 0.006*(0.4524-voltage) ));
#   voltage = voltage / 0.003;  

   if (voltage < 0.5) then
      return(0.0);
   end;
      
    # For UO BDL Nokia monitor (with nVidia 5700ultra Card)
   # Y = 0.0014x^2 - 0.0835x + 1.036
   double A = 0.0014;
   double B =  -0.0835;
   double C = 1.036;
   voltage = ( -B + sqrt ( pow(B,2.0) - 4.0 * A * ( C - voltage ))) / ( 2.0 * A );
#   voltage = voltage * 5.0; # convert to voltage [0-255] instead of a number from 0 to 51
#   if (voltage > 255.0) then
#      voltage = 255.0;
#   end;
   return voltage;
end;

# Change the color of all of the boxes to the correct values.
# Do that using calc_gray_voltage() above.
# This gets done once.
loop
   int num_bars = 128; # The number of lines that make up the picture. I.e. each bar is 128px high by 1px wide
   int height = 128;
   int width = 1;
   double count = 1.0;
   double rad = 0.0;
   double avg_value; # the average value of the sine wave (e.g. dc offset)
   double magnitude; # the average value + sin(theta) * magnitude = brightness of signal
   avg_value = 67.69237; #4%
   #avg_value = 65.79439252; #7%
   #avg_value = 62.85714286; #12%
   
   magnitude = 2.707692308; #4%
   #magnitude = 4.60560747; #7%
   #magnitude = 7.542857143; #12%
   
   double color = 0.0;
   double num_cycles = 2.0; # The number of cycles
until
   count > double(num_bars)
begin
   # Set the background color.  It's the average of the dark and
   # light portions. I.e. the "avg_value"
   if (count == 1.0) then
      #only set the background color on the first pass
      color = calc_gray_voltage(avg_value);
      loop
         int i = 1;
      until
         i > num_bars
      begin
         pics[i].set_background_color(int(color),int(color),int(color));
         i = i + 1;
      end;
      # make sure to set it for the targets too
      loop
         int i = 1;
      until
         i > NumPics
      begin
         target_array[i].set_background_color(int(color),int(color),int(color));
         i = i + 1;
      end;
      # and the pictures.  This helps to eliminate flicker
      pic1.set_background_color(int(color),int(color),int(color));
      default.set_background_color(int(color),int(color),int(color));
   end;
   # Take the count variable and generate the corresponding
   # radian value for that bar.
   rad = num_cycles / double(num_bars) * count * 2.0 * 3.14159;
   # use the variable color for multiple uses.
   # add the base value and the sine(rad) * magnitude
   # to generate a sine wave luminance grating.
   color = avg_value + magnitude*sin(rad);  
   # re-assign the color value to the "voltage" or "gun value"
   # i.e. 0-255 to use.
   color = calc_gray_voltage(color);
   # typecast color to an int and change the color,
   # height, and width
   boxes[int(count)].set_width(width);
   boxes[int(count)].set_height(height);
   boxes[int(count)].set_color(int(color),int(color),int(color));
   count = count + 1.0;
end;


# This function adds all of the boxes starting at the correct
# index.  I.e. it takes the sine wave gradient, and has
# the ability to shift it either left or right.
sub
   make_pic(int offset, int direction, int array_index)
begin;
   pics[array_index].clear();
   int temp_x;
   int temp_x_start = -64;

   int j = offset;
   if (j > 128) then
      j = j - 128;
   elseif (j < 1) then
      j = j + 128;
   end;
   int temp = 128;
   loop
      int count = 1;
   until
      count > 128
   begin;
      if (j > 128) then
         j = 1;
         temp = 128 - offset;
      end;
      temp_x = temp_x_start + count;
      pics[array_index].add_part(boxes[j], temp_x, 0); #pictures start at x = -64
      j = j + 1;
      count = count + 1;
   end;
end;
   

# This is the subroutine that controls the actual movement of the gradient.
# It calls the make_pic() function above to do the scrolls.
# It returns the starting position (index) of the last image.
# It does this so it knows where to start the next scroll at.
# Only pictures that have an event code are counted in the stimulus_manger


sub
   # 1 means scroll left
   # 2 means scroll right
   int scroll(int scroll_amount, int num_steps, int direction, int start_value, int e_code)
begin;
   int temp;
   int dir_mult;
   double temp2;
   if (direction == 1) then
      dir_mult = 1;
      main_stim.set_event_code("Left");
   else
      dir_mult = -1;
      main_stim.set_event_code("Right");
   end;
   main_stim.set_port_code(e_code);

   int i = 0;
   loop
   until
      i >= num_steps 
   begin
      #create the picture array
      temp = start_value + i * scroll_amount * dir_mult;
      # integer division, it truncates the decimal, therefore,
      # finds how far past 128 it is and subtracts it so it uses
      # a meaningful array index, i.e. 1<=i<=128
      temp = temp - (temp / 128) * 128;
      i = i + 1;
      make_pic(temp, direction, i);
   end;
   
   i = 1;
   loop
   until
      i >= num_steps + 1
   begin
      #display the picture array
      if (1 != i) then 
         main_stim.set_event_code("");
         main_stim.set_port_code(0);
      end;
      main_stim.set_stimulus(pics[i]);
      main_trial.present();
      pic1 = pics[i];
      i = i + 1;
   end;
   
   #default = pic1;
   default = pic1; # I hope this clears up the flickering
   isi_stim.set_stimulus(pic1);
   isi_trial.present();
   return (temp);
end;


int ecode;
int rate;
int dur;
int isi;
int temp; # used as a flag for scroll direction as well as a random int from 1..4
int last_offset = 1;
int flag;
int start_time;
string dir;
string last_dir;

loop
   bool test = false;
until
   test == true #end of file
begin;
   
   ecode = in.get_int();
   in.get_int(); #location...ignore this
   rate = in.get_int();
   dir = in.get_string();
   dur = in.get_int();
   isi = in.get_int();
   test = in.end_of_file();
   
   if (dir == "r") then
      temp = 2;
   elseif (dir == "l") then
      temp = 1;
   else 
      flag = 1
   end;
   isi_trial.set_duration(isi);
         
   if (flag == 1) then
      # show a picture
      temp = random(1,NumPics);
      main_stim.set_stimulus(target_array[temp]);
      main_stim.set_duration(dur);
      main_stim.set_event_code("Target");
      main_stim.set_port_code(ecode);
      main_trial.set_duration(stimuli_length);
      main_trial.present();
      isi_trial.present();
      flag = 0;                         
   else
      # find how many frames should be displayed.
      # normal duration is 100 ms, so, 100ms / 13.3 pics/sec = # pics
      # convert to an integer
      # 85 Hz -> 13.3 ms / frame
      dur = int( double(dur) / 13.3 );
      # if it's a more than half a frame, show the extra frame
      if (dur > int(13.3/2.0)) then
         dur = dur + 1;
      end;
      main_stim.set_duration(next_picture);
      main_stim.set_stimulus(pic1); 
      # scroll amount = 4 for 1/2 degree in 100 ms
      # scroll amount = 8 for 1 degree in 100 ms
      # scroll amount = 11 for 14.57Hz
      # scroll amount = 16 for 2 degrees in 100 ms
      last_offset = scroll(11, dur, temp, last_offset, ecode);
   end;
      
   last_dir = dir;
       
end; 
final_pic.present();
