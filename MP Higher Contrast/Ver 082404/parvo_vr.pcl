# VR Parvo
#  modified from regular_parvo.pcl
#  5/2004  RV

#Parvo PCL file

#open and sort through the header stuff in the
#dmparvo.lst file.

# The EGI interface is borrowed from Peter Pebler
#  and heavily modified by Kevin
#
# 4/9/2004 -  Now implements the full NetStation protocol.
#              Also, output square waves instead of sinesoidal
#              waves.  

# 6/2/2004  MODIFED for UO luminosity  pec
# 6/9/2004   luminosity formula

# 6/10/2004 new pictures RV

int NumPics=7;

loop until
   clock.time() > 0
begin end;

input_file in = new input_file;
in.open(".\\MagnoParvo_VR_STIMS\\dmparvo.lst");
#it has 15 lines of header
loop
   int i = 1;
until
   i > 15
begin
   in.get_line();
   i = i + 1;
end;

sub
   double calc_green_voltage(double voltage)
begin
   # I used a 2nd order polynomial fit for the
   # luminance values in excel.
   #Green Trendline EQ y = 0.0244*x^2 - 0.3523*x + 1.0918, for x in the set [0 <= x <= 51]
   # e. g. y = A * x^2 + B * X + C     (pec 2004.06.10)
   # in thi case A = 0.0244   B = - 0.3523 and C = 1.0918  
   #  Using the quadratic formula solved for y:
   #  voltage = (-B + sqrt ( B^2 - 4 * A * (C - y))) / 2 * A
   # For UO BDL Nokia monitor -- Booth 1  (with nVidia 5700ultra card)
   #Green Trendline EQ y = 0.001*x^2 - 0.0574*x + 0.7183, for x in the set [0 <= x <= 51]
   double A = 0.001;
   double B =  -0.0574;
   double C = 0.07183;
   if (voltage < 0.5) then
      return(0.0);
   end;
   
   # For Debbie's monitor:
   #voltage = 0.3523 + sqrt(0.12411529-0.0976*(1.0918-voltage));
   #voltage = voltage / 0.0488;  
   # For UO Nokia Booth 1 /nVidia 5700ultra -- stim1
#  voltage = 0.0574 + sqrt(0.00329476-0.004*(0.7183-voltage));
#  voltage = voltage / 0.002;

   voltage = ( -B + sqrt ( pow(B,2.0) - 4.0 * A * ( C - voltage ))) / ( 2.0 * A );
#   voltage = voltage * 5.0; # convert to voltage [0-255] instead of a number from 0 to 51
#  UO values already formulated for 0 - 255  pec 2004.06.10
   if (voltage > 255.0) then
      voltage = 255.0;
   end;
   return voltage;
end;

sub
   double calc_red_voltage(double voltage)
begin
   # I used a 2nd order polynomial fit for the
   # luminance values in excel.
   #Red Trendline EQ y = 0.0083*x^2 - 0.1146*x + 0.4524
   # For UO BDL Nokia monitor -- Booth 1 (with nVidia 5700ultra card) 
   # Red Trendline EQ y = 0.0003*x^2 - 0.0232*x + 0.353
   # anything lower, and it'll have problems. i.e. sqrt(-#)
   if (voltage < 0.056823) then
      return(0.0);
#      voltage = 0.056823;
   end;
#   voltage = 0.1146+sqrt(0.01313316-0.0332*(0.4524-voltage));
#   voltage = voltage / 0.0166;    

#   voltage = 0.0232+sqrt(0.00053824-0.012*(0.353-voltage));  
#   voltage = voltage / 0.0006;  
   double A = 0.0003;
   double B = -0.0232;
   double C = 0.353;
   voltage = ( -B + sqrt ( pow(B,2.0) - 4.0 * A * ( C - voltage ))) / ( 2.0 * A );
   voltage = voltage * 5.0; # convert to voltage [0-255] instead of a number from 0 to 51
   if (voltage > 255.0) then
      voltage = 255.0;
   end;
   return voltage;
end;

sub 
   picture make_pic(bool start_with_red_or_green, picture pic) 
begin

   # Change the color of all of the boxes to the correct values.
   # Do that using calc_green_voltage() and
   # calc_red_voltage() above.
   int num_bars = 126; # The number of lines that make up the picture. I.e. each bar is 128px high by 1px wide
   int height = 126;
   int width = 1;

   loop
      int cur_cycle = 1;
      bool green_flag = start_with_red_or_green; # toggles either green or red bars
      double count = 1.0;
      double avg_lum = 8.2; 
      double magnitude = 8.2; 
      double color = 0.0;
      double num_cycles = 4.5; # The number of cycles (try to get a red bar at the end of the
                                 # stimuli to eliminate the impression that it "shifts" left or right
      double period = double(num_bars) / num_cycles;
      int period_2 = int(period / 2.0);
      int period_4 = int(period / 4.0);
   until
      count > double(num_bars)
   begin
      color = avg_lum + magnitude; #solid bars instead of gradients      
    
      # Switch the color of the bar every half period.
      # A period being two bars, one of red and one of green
      # So this effectively makes it alternate colors
      if (cur_cycle > period_2) then
         cur_cycle = 1;
         if (green_flag) then
            green_flag = false;
         else
            green_flag = true;
         end;
      end;
      if (cur_cycle > period_4) then
         color = 0.0;
      end;

      if (green_flag) then
         color = calc_green_voltage(color);
         boxes[int(count)].set_color(0,int(color),0);
      else
         color = calc_red_voltage(color);
         boxes[int(count)].set_color(int(color),0,0);
      end;
     
      # typecast color to an int and change the color
      # height, and width
      boxes[int(count)].set_width(width);
      boxes[int(count)].set_height(height);
      count = count + 1.0;
      cur_cycle = cur_cycle + 1;
   end;
   
   # Now that all of the bars have their correct colors,
   # fill the picture with those bars.
   pic.clear();
   loop
      int i = 1;
      int x_start = -(num_bars/2); #initial x starting position
      int y_start = 0; # all bars will have y=0;
   until
      i > num_bars
   begin
      pic.add_part(boxes[i],x_start+i,y_start);   
      i = i + 1;
   end; # end of the loop
   return(pic);       
end; #end sub make_pic

   
int ecode1; 
int dur;
int isi;
int temp;
int port_code;
bool cr = false; #answered correclty (not implemented yet)
string pic_type;
pic1 = make_pic(true,pic1);
default = make_pic(false,default);
loop
   bool test = false;
until
   test == true
begin;

   #>> read in stuff from the parvo file<<
   ecode1 = in.get_int(); 
   in.get_int();
   pic_type = in.get_string();
   dur = in.get_int();
   isi = in.get_int();
   test = in.end_of_file();
   
   if (pic_type == "rg") then
      pic1 = make_pic(true,pic1);
      main_stim.set_stimulus(pic1);
      # it was decided that the "siwtched"
      # pics should always be displayed for 200ms
#      dur = 244;                       # RV this now comes from file
      if (101 == ecode1) then
         port_code = 101;
      else
         port_code = 31;
      end;
   else
      temp = random(1,NumPics);
      main_stim.set_stimulus(target_array[temp]);
      # it was decided that the "targets"
      # should always be displayed for 500ms
#      dur = 500;                    # RV this now comes from file
   end;
   main_stim.set_duration(dur);
   isi_stim.set_event_code(string(ecode1)); 
   isi_stim.set_port_code(ecode1);
   isi_stim.set_duration(isi);
   main_trial.present();
   default = make_pic(false, default);
   isi_trial.present();

end;
 final_pic.present();
 